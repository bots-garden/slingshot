{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SlingShot","text":"<p>SlingShot is a Wasm runner to run or serve Extism Wasm plug-ins</p> Run a wasm plug-in<pre><code>./slingshot run --wasm=./hello.wasm --handler=hello --input=\"Bob \ud83e\udd13\"\n</code></pre> Serve a wasm plug-in as a function<pre><code>./slingshot listen --wasm=./hello.wasm --handler=handle --http-port=7070\n</code></pre> Trigger a wasm plug-in with Redis messages<pre><code>./slingshot redis subscribe --wasm=./hello.wasm --handler=message \\\n--uri=${REDIS_URI} \\\n--client-id=007 \\\n--channel=news\n</code></pre> Trigger a wasm plug-in with NATS messages (\u270b experimental \ud83d\udea7 WIP)<pre><code>./slingshot nats subscribe --wasm=./hello.wasm --handler=message \\\n--url=${NATS_SERVER_URL} \\\n--connection-id=007 \\\n--subject=news\n</code></pre> Execute a remote wasm file<pre><code>./slingshot run \\\n--wasm-url=\"http://0.0.0.0:9000/print.wasm\" \\\n--wasm=./print.wasm \\\n--handler=callHandler \\\n--input=\"\ud83e\udd13 I'm a geek\"\n</code></pre>"},{"location":"#how-is-slingshot-developed","title":"How is Slingshot developed?","text":"<p>Slingshot is developed in Go with Wazero<sup>1</sup> as the Wasm runtime and Extism<sup>2</sup>, which offers a Wazero-based Go SDK and a Wasm plugin system.</p>"},{"location":"#install-slingshot","title":"Install SlingShot","text":"<ul> <li>Download the latest release of SlingShot: https://github.com/bots-garden/slingshot/releases for your machine and OS.</li> <li>Rename it to <code>slingshot</code></li> <li>Check by typing: <code>./slingshot version</code></li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#write-extism-plug-ins","title":"\ud83d\ude80 Write Extism plug-ins","text":"<ul> <li>Write &amp; run a plug-in</li> <li>Write &amp; serve a plug-in as a nano-service</li> <li>Write a Redis subscriber plug-in</li> <li>Write a Redis publisher plug-in</li> <li>Write a NATS subscriber plug-in</li> <li>Write a NATS publisher plug-in</li> </ul> <ol> <li> <p>Wazero is a project from Tetrate \u21a9</p> </li> <li> <p>Extism is a project from Dylibso \u21a9</p> </li> </ol>"},{"location":"extism-flags/","title":"Extism flags","text":"<p>The Slingshot runner can use these additional flags:</p> <ul> <li><code>--log-level</code></li> <li><code>--allow-hosts</code></li> <li><code>--config</code></li> <li><code>--allow-paths</code></li> </ul> <p>These flags allow to use some specific Extism PDKs API.</p>"},{"location":"extism-flags/#-log-level","title":"<code>--log-level</code>","text":"<p>Possible values: error, warn, info, debug, trace</p> <p>Usage: <pre><code>./slingshot run \\\n--wasm=./print.wasm \\\n--handler=callHandler \\\n--input=\"\ud83e\udd13 I'm a geek\" \\\n--log-level info </code></pre></p> <p>Plugin source code:</p> Go <pre><code>pdk.Log(pdk.LogInfo, \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\")\n</code></pre>"},{"location":"extism-flags/#-allow-hosts","title":"<code>--allow-hosts</code>","text":"<p>Usage: <pre><code>./slingshot run \\\n--wasm=./print.wasm \\\n--handler=callHandler \\\n--input=\"\ud83e\udd13 I'm a geek\" \\\n--allow-hosts *,*.google.com,yo.com\n</code></pre></p> <p>Plugin source code:</p> Go <pre><code>req := pdk.NewHTTPRequest(\"GET\", \"https://jsonplaceholder.typicode.com/todos/1\")\n</code></pre>"},{"location":"extism-flags/#-config","title":"<code>--config</code>","text":"<p>Usage: <pre><code>./slingshot run \\\n--wasm=./print.wasm \\\n--handler=callHandler \\\n--input=\"\ud83e\udd13 I'm a geek\" \\\n--config '{\"firstName\":\"Borane\",\"lastName\":\"Morane\"}'\n</code></pre></p> <p>Plugin source code:</p> Go <pre><code>firstName, _ := pdk.GetConfig(\"firstName\")\nlastName, _ := pdk.GetConfig(\"lastName\")\npdk.Log(pdk.LogInfo, firstName)\npdk.Log(pdk.LogInfo, lastName)\n</code></pre>"},{"location":"extism-flags/#-allow-paths","title":"<code>--allow-paths</code>","text":"<p>No implemented yet</p>"},{"location":"write-nats-publisher/","title":"Write a NATS publisher plug-in","text":"<p>We are going to use it to publish message to the NATS subscriber</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitNatsConnection\nfunc hostInitNatsConnection(offset uint64) uint64\nfunc InitNatsConnection(natsConnectionId string, natsUrl string) (string, error) {\njsonStrArguments := `{\"id\":\"` + natsConnectionId + `\",\"url\":\"` + natsUrl + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitNatsConnection(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitNatsConnection) returns a JSON buffer:\n// {\n//   \"success\": \"the NATS connexion id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hostNatsPublish\nfunc hostNatsPublish(offset uint64) uint64\nfunc NatsPublish(natsServer string, subject string, data string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the NATS client\",\n//    \"subject\": \"name\",\n//    \"data\": \"Bob Morane\"\n// }\n//jsonStr := `{\"url\":\"` + natsServer + `\",\"subject\":\"` + subject + `\",\"data\":\"` + data + `\"}`\njsonStr := `{\"id\":\"` + natsServer + `\",\"subject\":\"` + subject + `\",\"data\":\"` + data + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStr)\n// Call host function with the offset of the arguments\noffset := hostNatsPublish(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostNatsPublish) returns a JSON buffer:\n// {\n//   \"success\": \"the message\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffResult := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffResult)\nJSONData, err := parser.ParseBytes(buffResult)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export publish\nfunc publish() uint64 {\ninput := pdk.Input()\nnatsURL := GetEnv(\"NATS_URL\")\nPrint(\"\ud83d\udc9c NATS_URL: \" + natsURL)\nidNatsConnection, errInit := InitNatsConnection(\"natsconn01\", natsURL)\nif errInit != nil {\nPrint(\"\ud83d\ude21 \" + errInit.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + idNatsConnection)\n}\nres, err := NatsPublish(\"natsconn01\", \"news\", string(input))\nif err != nil {\nPrint(\"\ud83d\ude21 \" + err.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + res)\n}\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct NatsConfig {\npub id: String,\npub url: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct NatsMessage {\npub id: String,\npub subject: String,\npub data: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum NatsError {\n#[error(\"Nats Connection issue\")]\nConnectionFailure,\n#[error(\"Store issue\")]\nMessageFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostInitNatsConnection(offset: u64) -&gt; u64;\n}\npub fn init_nats_connection(nats_connection_id: String, nats_url: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the NATS connection\",\n//    \"url\": \"URL of the NATS server\"\n// }\nlet args = NatsConfig {\nid: nats_connection_id,\nurl: nats_url,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostInitNatsConnection(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostInitNatsConnection) returns a JSON buffer:\n// {\n//   \"success\": \"id of the connection\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(NatsError::ConnectionFailure.into());\n}\n}\nextern \"C\" {\nfn hostNatsPublish(offset: u64) -&gt; u64;\n}\npub fn nats_publish(nats_connection_id: String, subject: String, data: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the NATS client\",\n//    \"subject\": \"name\",\n//    \"data\": \"Bob Morane\"\n// }\nlet args = NatsMessage {\nid: nats_connection_id, subject: subject,\ndata: data,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostNatsPublish(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function returns a JSON buffer:\n// {\n//   \"success\": \"OK\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(NatsError::MessageFailure.into());\n}\n}\n#[plugin_fn]\npub fn publish(input: String) -&gt; FnResult&lt;u64&gt; {\nlet nats_url : String = get_env(\"NATS_URL\".to_string());\nlet nats_connection : Result&lt;String, Error&gt; = init_nats_connection(\"natsconn01\".to_string(), nats_url);\nmatch nats_connection {\nOk(value) =&gt; print(\"\ud83e\udd80 nats connection: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch nats_publish(\"natsconn01\".to_string(), \"news\".to_string(), input.to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 \ud83d\ude42 \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"write-nats-publisher/#build","title":"Build","text":"GoRust <pre><code>tinygo build -scheduler=none --no-debug \\\n    -o natspub.wasm \\\n    -target wasi main.go\n</code></pre> <pre><code>cargo clean\ncargo build --release --target wasm32-wasi #--offline\nls -lh ./target/wasm32-wasi/release/*.wasm\ncp ./target/wasm32-wasi/release/*.wasm .\n</code></pre>"},{"location":"write-nats-publisher/#run-the-plug-in-to-publish-a-message","title":"Run the plug-in to publish a message","text":"<pre><code>export NATS_URL=\"nats://0.0.0.0:4222\"\n./slingshot run --wasm=./natspub.wasm \\\n--handler=publish \\\n--input=\"I \ud83d\udc9c Wasm \u2728\"\n</code></pre> <p>On the subscriber side, you shoul read: <pre><code>\ud83d\udc4b message: {\"subject\":\"news\",\"data\":\"I \ud83d\udc9c Wasm \u2728\"}\n</code></pre></p>"},{"location":"write-nats-subscriber/","title":"Write a NATS subscriber plug-in","text":"<p>You need to install a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation</p> GoRust <pre><code>package main\nimport (\n\"github.com/extism/go-pdk\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export message\nfunc message() uint64 {\n// read function argument from the memory\ninput := pdk.Input()\nPrint(\"\ud83d\udc4b message: \" + string(input))\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\n#[plugin_fn]\npub fn message(input: String) -&gt; FnResult&lt;u64&gt; {\nprint(\"\ud83d\udc4b message: \".to_string() + &amp;input);\nOk(0)\n}\n</code></pre>"},{"location":"write-nats-subscriber/#build","title":"Build","text":"GoRust <pre><code>#!/bin/bash\ntinygo build -scheduler=none --no-debug \\\n-o natssub.wasm \\\n-target wasi main.go\n</code></pre> <pre><code>#!/bin/bash\ncargo clean\ncargo build --release --target wasm32-wasi\nls -lh ./target/wasm32-wasi/release/*.wasm\ncp ./target/wasm32-wasi/release/*.wasm .\n</code></pre>"},{"location":"write-nats-subscriber/#run","title":"Run","text":"<pre><code>#!/bin/bash\n./slingshot nats subscribe \\\n--wasm=./natssub.wasm \\\n--handler=message \\\n--url=nats://0.0.0.0:4222 \\\n--connection-id=natsconn01 \\\n--subject=news\n\n# Output:\n\ud83c\udf0d NATS URL      : *****\n\ud83c\udf0d NATS Connection Id: natsconn01\n\ud83d\ude80 handler           : message\n\ud83d\udce6 wasm              : ./natssub.wasm\n\ud83d\udcfa Subject           : news\n</code></pre>"},{"location":"write-nats-subscriber/#trigger-the-plugin","title":"Trigger the plugin","text":"<p>You need a NATS client. It's easy to write one with Go: <pre><code>package main\nimport (\n\"fmt\"\n\"github.com/nats-io/nats.go\"\n)\nfunc main() {\n// Connect to a server\n//nc, err := nats.Connect(\"nats://0.0.0.0:4222\")\nnc, err := nats.Connect(nats.DefaultURL)\nif err != nil {\nfmt.Println(err.Error())\n}\ndefer nc.Close()\nerr = nc.Publish(\"news\", []byte(\"Hello World\"))\nif err != nil {\nfmt.Println(err.Error())\n}\n}\n</code></pre></p> <p>Publish message(s): <pre><code>go run main.go\n</code></pre></p>"},{"location":"write-nats-subscriber/#output","title":"Output","text":"<pre><code>\ud83d\udc4b message: {\"id\":\"natscli\",\"subject\":\"news\",\"data\":\"Hello World\"}\n</code></pre>"},{"location":"write-plug-in/","title":"Write and run a plug-in","text":"<p>Official documentation: https://extism.org/docs/category/write-a-plug-in</p> GoRustJavaScript <pre><code>package main\nimport (\n\"github.com/extism/go-pdk\"\n)\n//export hello\nfunc hello() {\n// read function argument from the shared memory\ninput := pdk.Input()\noutput := \"\ud83d\udc4b Hello \" + string(input)\n// copy output to shared memory\nmem := pdk.AllocateString(output)\npdk.OutputMemory(mem)\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\n#[plugin_fn]\npub fn hello(input: String) -&gt; FnResult&lt;String&gt; {\nlet output : String = \"\ud83d\udc4b Hello \".to_string() + &amp;input;\nOk(output)\n}\n</code></pre> <pre><code>function hello() {\n// read function argument from the memory\nlet input = Host.inputString()\nlet output = \"\ud83d\udc4b Hello \" + input\n// copy output to host memory\nHost.outputString(output)\n}\nmodule.exports = {hello}\n</code></pre>"},{"location":"write-plug-in/#build","title":"Build","text":"GoRustJavaScript <pre><code>#!/bin/bash\ntinygo build -scheduler=none --no-debug \\\n-o hello.wasm \\\n-target wasi main.go\n</code></pre> <pre><code>#!/bin/bash\ncargo clean\ncargo build --release --target wasm32-wasi\nls -lh ./target/wasm32-wasi/release/*.wasm\ncp ./target/wasm32-wasi/release/*.wasm .\n</code></pre> <pre><code>#!/bin/bash\nextism-js index.js -o hello.wasm\n</code></pre>"},{"location":"write-plug-in/#run","title":"Run","text":"<pre><code>#!/bin/bash\n./slingshot run --wasm=./hello.wasm --handler=hello --input=\"Bob \ud83e\udd13\"\n</code></pre>"},{"location":"write-plug-in/#output","title":"Output","text":"<pre><code>\ud83d\udc4b Hello Bob \ud83e\udd13\n</code></pre>"},{"location":"write-redis-publisher/","title":"Write a Redis publisher plug-in","text":"<p>We are going to use it to publish message to this subscriber</p> Go <pre><code>package main\nimport (\n\"errors\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitRedisClient\nfunc hostInitRedisClient(offset uint64) uint64\nfunc InitRedisClient(redisClientId string, redisUri string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\njsonStrArguments := `{\"id\":\"` + redisClientId + `\",\"uri\":\"` + redisUri + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitRedisClient(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the redis client id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hostRedisPublish\nfunc hostRedisPublish(offset uint64) uint64\nfunc RedisPublish(redisClientId string, channel string, payload string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"channel\": \"name\",\n//    \"payload\": \"Bob Morane\"\n// }\njsonStr := `{\"id\":\"` + redisClientId + `\",\"channel\":\"` + channel + `\",\"payload\":\"` + payload + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStr)\n// Call host function with the offset of the arguments\noffset := hostRedisPublish(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostMemorySet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffResult := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffResult)\nJSONData, err := parser.ParseBytes(buffResult)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export publish\nfunc publish() uint64 {\ninput := pdk.Input()\nredisURI := GetEnv(\"REDIS_URI\")\nidRedisClient, errInit := InitRedisClient(\"pubsubcli\", redisURI)\nif errInit != nil {\nPrint(\"\ud83d\ude21 \" + errInit.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + idRedisClient)\n}\nRedisPublish(\"pubsubcli\", \"news\", string(input))\nreturn 0\n}\nfunc main() {}\n</code></pre>"},{"location":"write-redis-publisher/#build","title":"Build","text":"Go <pre><code>#!/bin/bash\ntinygo build -scheduler=none --no-debug \\\n-o redispub.wasm \\\n-target wasi main.go\n</code></pre>"},{"location":"write-redis-publisher/#run-the-plug-in-to-publish-a-message","title":"Run the plug-in to publish a message","text":"<pre><code>#!/bin/bash\nREDIS_URI=${REDIS_URI} ./slingshot run --wasm=./redispub.wasm \\\n--handler=publish \\\n--input=\"I \ud83d\udc9c Wasm \u2728\"\n</code></pre> <p>On the subscriber side, you shoul read: <pre><code>\ud83d\udc4b message: news I \ud83d\udc9c Wasm \u2728\n</code></pre></p>"},{"location":"write-redis-subscriber/","title":"Write a Redis subscriber plug-in","text":"Go <pre><code>package main\nimport (\n\"github.com/extism/go-pdk\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export message\nfunc message() uint64 {\n// read function argument from the memory\ninput := pdk.Input()\nPrint(\"\ud83d\udc4b message: \" + string(input))\nreturn 0\n}\nfunc main() {}\n</code></pre>"},{"location":"write-redis-subscriber/#build","title":"Build","text":"Go <pre><code>#!/bin/bash\ntinygo build -scheduler=none --no-debug \\\n-o redissub.wasm \\\n-target wasi main.go\n</code></pre>"},{"location":"write-redis-subscriber/#run","title":"Run","text":"<pre><code>#!/bin/bash\n./slingshot redis subscribe \\\n--wasm=./redissub.wasm \\\n--handler=message \\\n--uri=${REDIS_URI} \\\n--client-id=pubsubcli \\\n--channel=news\n\n# Output:\n\ud83c\udf0d redis URI      : *****\n\ud83c\udf0d redis Client Id: pubsubcli\n\ud83d\ude80 handler        : message\n\ud83d\udce6 wasm           : ./redissub.wasm\n\ud83d\udcfa channel        : news\n</code></pre>"},{"location":"write-redis-subscriber/#trigger-the-plugin","title":"Trigger the plugin","text":"<p>Connect to the Redis server: <pre><code>#!/bin/bash\nredis-cli -u  ${REDIS_URI}\n</code></pre></p> <p>Publish message(s): <pre><code>redis.aivencloud.com:17170&gt; PUBLISH news \"Hello World\"\n</code></pre></p>"},{"location":"write-redis-subscriber/#output","title":"Output","text":"<pre><code>\ud83d\udc4b message: {\"id\":\"pubsubcli\",\"channel\":\"news\",\"payload\":\"Hello World\"}\n</code></pre>"},{"location":"write-service/","title":"Write and serve a plug-in as a nano-service","text":"GoRustJavaScript <pre><code>package main\nimport (\n\"strings\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\nvar parser = fastjson.Parser{}\n//export handle\nfunc handle()  {\n// read function argument from the memory\nhttp_request_data := pdk.Input()\nvar text string\nvar code string\nJSONData, err := parser.ParseBytes(http_request_data)\nif err != nil {\ntext = \"\ud83d\ude21 Error: \" + err.Error()\ncode = \"500\"\n} else {\ntext = \"\ud83e\ude75 Hello \" + string(JSONData.GetStringBytes(\"body\"))\ncode = \"200\"\n}\nheaders := []string{\n`\"Content-Type\": \"application/json; charset=utf-8\"`,\n`\"X-Slingshot-version\": \"0.0.0\"`,\n}\nheadersStr := strings.Join(headers, \",\")\nresponse := `{\"headers\":{` + headersStr + `}, \"textBody\": \"` + text + `\", \"statusCode\": `+ code +`}`\nmem := pdk.AllocateString(response)\n// copy output to host memory\npdk.OutputMemory(mem)   }\nfunc main() {}\n</code></pre> <pre><code>use std::collections::HashMap;\nuse extism_pdk::*;\nuse json::Value;\nuse serde::{Serialize, Deserialize};\n#[derive(Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct Response {\npub text_body: String,\npub json_body: Value,\npub headers : HashMap&lt;String,String&gt;,\npub status_code: i64\n}\n#[derive(Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct Request {\npub body: String,\npub base_url: String,\npub headers : HashMap&lt;String,String&gt;,\npub method: String\n}\n#[plugin_fn]\npub fn handle(http_request_data: String) -&gt; FnResult&lt;Json&lt;Response&gt;&gt; {\nlet request : Request = serde_json::from_str(&amp;http_request_data).unwrap();\nlet message: String = \"\ud83e\ude75 Hello \".to_string() + &amp;request.body;\nlet mut headers: HashMap&lt;String, String&gt; = HashMap::new();\nheaders.insert(\"Content-Type\".to_string(), \"text/plain; charset=utf-8\".to_string());\nheaders.insert(\"X-Slingshot-version\".to_string(), \"0.0.0\".to_string());\nlet response : Response = Response { text_body: message, json_body: serde_json::from_str(\"{}\")?, headers , status_code: 200 };\nOk(Json(response))\n}\n</code></pre> <pre><code>function handle() {\n// read function argument from the memory\nlet http_request_data = Host.inputString()\nlet JSONData = JSON.parse(http_request_data)\nlet text = \"\ud83d\udc9b Hello \" + JSONData.body\nlet response = {\nheaders: {\n\"Content-Type\": \"application/json; charset=utf-8\",\n\"X-Slingshot-version\": \"0.0.0\"\n},\ntextBody: text,\nstatusCode: 200\n}\n// copy output to host memory\nHost.outputString(JSON.stringify(response))\n}\nmodule.exports = {handle}\n</code></pre>"},{"location":"write-service/#build","title":"Build","text":"GoRustJavaScript <pre><code>#!/bin/bash\ntinygo build -scheduler=none --no-debug \\\n-o hello.wasm \\\n-target wasi main.go\n</code></pre> <pre><code>#!/bin/bash\ncargo clean\ncargo build --release --target wasm32-wasi\nls -lh ./target/wasm32-wasi/release/*.wasm\ncp ./target/wasm32-wasi/release/*.wasm .\n</code></pre> <pre><code>#!/bin/bash\nextism-js index.js -o hello.wasm\n</code></pre>"},{"location":"write-service/#run","title":"Run","text":"<pre><code>#!/bin/bash\n./slingshot listen --wasm=./hello.wasm --handler=handle --http-port=7070\n\ud83c\udf0d http-port: 7070\n\ud83d\ude80 handler  : handle\n\ud83d\udce6 wasm     : ./hello.wasm\n\ud83c\udf0d slingshot server is listening on: 7070\n</code></pre>"},{"location":"write-service/#query-the-service","title":"Query the service","text":"<pre><code>#!/bin/bash\ncurl --verbose \\\nhttp://localhost:7070 \\\n-H 'content-type: text/plain; charset=utf-8' \\\n-d '\ud83d\ude04 Bob Morane'\n</code></pre>"},{"location":"write-service/#output","title":"Output","text":"<pre><code>&gt; POST / HTTP/1.1\n&gt; Host: localhost:7070\n&gt; User-Agent: curl/7.88.1\n&gt; Accept: */*\n&gt; content-type: text/plain; charset=utf-8\n&gt; Content-Length: 15\n&gt; &lt; HTTP/1.1 200 OK\n&lt; Date: Tue, 15 Aug 2023 14:11:59 GMT\n&lt; Content-Type: application/json; charset=utf-8\n&lt; Content-Length: 26\n&lt; X-Slingshot-Version: 0.0.0\n&lt; * Connection #0 to host localhost left intact\n\ud83e\ude75 Hello \ud83d\ude04 Bob Morane\n</code></pre>"},{"location":"host-functions/display/","title":"\ud83d\udee0\ufe0f Host functions","text":""},{"location":"host-functions/display/#hostprint","title":"hostPrint","text":"<p><code>hostPrint</code>: print a message (from the wasm module).</p> GoRust <pre><code>import (\n\"strings\"\n\"github.com/extism/go-pdk\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hello\nfunc hello() uint64 {\nPrint(\"\ud83d\udc4b hello world \ud83c\udf0d\")\nreturn 0\n}\n</code></pre> <pre><code>use extism_pdk::*;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\n#[plugin_fn]\npub fn hello(_input: String) -&gt; FnResult&lt;u64&gt; {\nprint(\"\ud83d\udc4b hello world \ud83c\udf0d\".to_string());\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/display/#hostlog","title":"hostLog","text":"<p><code>hostLog</code>: log a message (from the wasm module).</p> GoRust <pre><code>import (\n\"strings\"\n\"github.com/extism/go-pdk\"\n)\n//export hostLog\nfunc hostLog(offset uint64) uint64\nfunc Log(text string) {\nmemoryText := pdk.AllocateString(text)\nhostLog(memoryText.Offset())\n}\n//export hello\nfunc hello() uint64 {\nLog(\"\ud83d\ude42 have a nice day \ud83c\udfd6\ufe0f\")\nreturn 0\n}\n</code></pre> <pre><code>use extism_pdk::*;\nextern \"C\" {\nfn hostLog(ptr: u64) -&gt; u64;\n}\npub fn log(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostLog(memory_text.offset) };\n}\n#[plugin_fn]\npub fn hello(_input: String) -&gt; FnResult&lt;u64&gt; {\nlog(\"\ud83d\ude42 have a nice day \ud83c\udfd6\ufe0f\".to_string());\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/env/","title":"\ud83d\udee0\ufe0f Host functions","text":""},{"location":"host-functions/env/#hostgetenv","title":"hostGetEnv","text":"<p><code>hostGetEnv</code>: read an environment variable.</p> GoRust <pre><code>package main\nimport (\n\"github.com/extism/go-pdk\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\n//export hello\nfunc hello() uint64 {\nmessage := GetEnv(\"MESSAGE\")\nPrint(\"\ud83e\udd16 MESSAGE=\" + message)\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nlet message : String = get_env(\"MESSAGE\".to_string());\nprint(\"\ud83e\udd80 MESSAGE=\".to_string() + &amp;message);\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/files/","title":"\ud83d\udee0\ufe0f Host functions","text":""},{"location":"host-functions/files/#hostreadfile","title":"hostReadFile","text":"<p><code>hostReadFile</code>: read the content of a file.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\nvar parser = fastjson.Parser{}\n// GetJsonFromBytes\n// Convert a buffer (`[]byte`) into a JSON value\nfunc GetJsonFromBytes(buffer []byte) (*fastjson.Value, error) {\nreturn parser.ParseBytes(buffer)\n}\n//export hostReadFile\nfunc hostReadFile(offset uint64) uint64\nfunc ReadFile(filePath string) (string, error) {\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(filePath)\n// Call host function with the offset of the arguments\noffset := hostReadFile(arguments.Offset())\n// Get result from the shared memory\nmemoryResult := pdk.FindMemory(offset)\nbuffResult := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffResult)\nJSONData, err := GetJsonFromBytes(buffResult)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\ncontent, err := ReadFile(\"./hello.txt\")\nif err != nil {\nPrint(\"\ud83d\ude21 \" + err.Error())\n} else {\nPrint(content)\n}\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum FileError {\n#[error(\"Read issue\")]\nReadFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostReadFile(ptr: u64) -&gt; u64;\n}\npub fn read_file(file_path: String) -&gt; Result&lt;String, Error&gt; {\n// Copy the string value to the shared memory\nlet mut memory_str: Memory = extism_pdk::Memory::new(file_path.len());\nmemory_str.store(file_path);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostReadFile(memory_str.offset) };\n// Get result\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(FileError::ReadFailure.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;String&gt; {\nmatch read_file(\"./hello.txt\".to_string()) {\nOk(value) =&gt; print(value.to_string()),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nlet output : String = \"\ud83d\udc4b Hello \".to_string();\nOk(output)\n}\n</code></pre>"},{"location":"host-functions/files/#hostwritefile","title":"hostWriteFile","text":"<p><code>hostWriteFile</code>: write a content to a file.</p> GoRust <pre><code>package main\nimport (\n\"encoding/base64\"\n\"errors\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\nvar parser = fastjson.Parser{}\n// GetJsonFromBytes\n// Convert a buffer (`[]byte`) into a JSON value\nfunc GetJsonFromBytes(buffer []byte) (*fastjson.Value, error) {\nreturn parser.ParseBytes(buffer)\n}\n//export hostWriteFile\nfunc hostWriteFile(offset uint64) uint64\nfunc WriteFile(filePath string, contentFile string) error {\ncontent := base64.StdEncoding.EncodeToString([]byte(contentFile))\njsonStrArguments := `{\"path\":\"` + filePath + `\",\"content\":\"` + content + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostWriteFile(arguments.Offset())\n// Get result from the shared memory\nmemoryResult := pdk.FindMemory(offset)\nbuffResult := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffResult)\nJSONData, err := GetJsonFromBytes(buffResult)\nif err != nil {\nreturn err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn nil\n} else {\nreturn errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\ntext := `\n    &lt;html&gt;\n    &lt;h1&gt;\"Hello World!!!\"&lt;/h1&gt;\n    &lt;/html&gt;\n    `\nerr := WriteFile(\"./index.html\", text)\nif err != nil {\nPrint(\"\ud83d\ude21 \" + err.Error())\n}\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct FileArguments {\npub path: String,\npub content: String,\n}\n#[derive(Error, Debug)]\npub enum FileError {\n#[error(\"Write issue\")]\nWriteFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostWriteFile(ptr: u64) -&gt; u64;\n}\npub fn write_file(file_path: String, content_file: String) -&gt; Result&lt;String, Error&gt; {\nlet args = FileArguments {\npath: file_path,\ncontent:  content_file,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostWriteFile(memory_json_str.offset) };\n// Get result\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(FileError::WriteFailure.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;String&gt; {\nlet text = \"&lt;html&gt;&lt;h1&gt;Hello World!!!&lt;/h1&gt;&lt;/html&gt;\".to_string();\nmatch write_file(\"./index.html\".to_string(), text) {\nOk(value) =&gt; print(value.to_string()),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nlet output : String = \"\ud83d\udc4b Hello \".to_string();\nOk(output)\n}\n</code></pre>"},{"location":"host-functions/intro/","title":"\ud83d\udee0\ufe0f Host functions","text":"<p>This section explains how to use the host functions with an Extism wasm plugin.</p> <ul> <li>Display</li> <li>Environment</li> <li>Memory Cache</li> <li>Redis Cache</li> <li>Redis PubSub</li> <li>Nats Publish</li> </ul> <p>About Extism Host Functions</p> <p>You can find more information into the Extism documentation: https://extism.org/docs/concepts/host-functions. Each Plug-in Development Kits provides the \"bridge helpers\" allowing using the host function callbacks of the host application from the guest wasm plug-in. Then you need to \"assemble\" the \"bridge helpers\" to call the host function. It's not always straightforward, and you need to do it for every language you use.</p> <p>Right now, we want to make sure that SlingShot is compliant with Extism PDKs and that's why we're only working on the \"host\" part.</p> <p>In the future, the Slingshot project will propose layers of abstraction to simplify the use of host functions.</p> <p>\ud83d\udc40 you can follow these issues:</p> <ul> <li>Create slingshot-go-pdk</li> <li>Create slingshot-rust-pdk</li> </ul>"},{"location":"host-functions/mem/","title":"\ud83d\udee0\ufe0f Host functions","text":"<p>Similar helpers are already provided by the Extism PDK(s) and are more complete</p> <ul> <li>Go: https://github.com/extism/go-pdk/blob/main/extism_pdk.go</li> <li>Rust: https://github.com/extism/rust-pdk/blob/main/src/var.rs</li> </ul> <p><code>hostMemorySet</code> and <code>hostMemoryGet</code> have been developed to validate our understanding of how the Extism PDKs work.</p>"},{"location":"host-functions/mem/#hostmemoryset","title":"hostMemorySet","text":"<p><code>hostMemorySet</code>: store a key/value into a memory map.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\nvar parser = fastjson.Parser{}\n//export hostMemorySet\nfunc hostMemorySet(offset uint64) uint64\nfunc MemorySet(key string, value string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"key\": \"name\",\n//    \"value\": \"Bob Morane\"\n// }\njsonStr := `{\"key\":\"` + key + `\",\"value\":\"` + value + `\"}`\n// Copy the string value to the shared memory\nkeyAndValue := pdk.AllocateString(jsonStr)\n// Call host function with the offset of the arguments\noffset := hostMemorySet(keyAndValue.Offset())\n// Get result from the shared memory\n// The host function (hostMemorySet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffResult := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffResult)\nJSONData, err := parser.ParseBytes(buffResult)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\n_, err := MemorySet(\"bob\", \"Bob Morane\")\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct MemArguments {\npub key: String,\npub value: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum MemError {\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostMemorySet(offset: u64) -&gt; u64;\n}\npub fn memory_set(key: String, value: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"key\": \"name\",\n//    \"value\": \"Bob Morane\"\n// }\nlet record = MemArguments {\nkey: key,\nvalue: value,\n};\nlet json_str: String = serde_json::to_string(&amp;record).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostMemorySet(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostMemorySet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(MemError::StoreFailure.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nmatch memory_set(\"bob\".to_string(), \"Bob Morane\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 saved value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/mem/#hostmemoryget","title":"hostMemoryGet","text":"<p><code>hostMemoryGet</code>: get value with a key from a memory map.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\nvar parser = fastjson.Parser{}\n//export hostMemoryGet\nfunc hostMemoryGet(offset uint64) uint64\nfunc MemoryGet(key string) (string, error) {\n// Copy argument to memory\nmemoryKey := pdk.AllocateString(key)\n// Call the host function\noffset := hostMemoryGet(memoryKey.Offset())\n// Get result (the value associated to the key) from shared memory\n// The host function (hostMemoryGet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryValue := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryValue.Length())\nmemoryValue.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\nvalue, err := MemoryGet(\"bob\")\nif err != nil {\nPrint(\"\ud83d\ude21 ouch! \" + err.Error())\n} else {\nPrint(\"value: \" + value)\n}\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum MemError {\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostMemoryGet(offset: u64) -&gt; u64;\n}\npub fn memory_get(key: String) -&gt; Result&lt;String, Error&gt; {\n// Copy argument to memory\nlet mut memory_key: Memory = extism_pdk::Memory::new(key.len());\nmemory_key.store(key);\n// Call the host function\nlet offset: u64 = unsafe { hostMemoryGet(memory_key.offset) };\n// Get result (the value associated to the key) from shared memory\n// The host function (hostMemoryGet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(MemError::NotFound.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nmatch memory_get(\"bob\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch memory_get(\"sam\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/nats/","title":"\ud83d\udee0\ufe0f Host functions","text":""},{"location":"host-functions/nats/#hostinitnatsconnection-hostnatspublish","title":"hostInitNatsConnection &amp; hostNatsPublish","text":"<p>\ud83d\udc40 Look at this sample: Nats publisher plug-in</p>"},{"location":"host-functions/redis-pubsub/","title":"\ud83d\udee0\ufe0f Host functions","text":""},{"location":"host-functions/redis-pubsub/#hostredispublish","title":"hostRedisPublish","text":"<p>\ud83d\udc40 Look at this sample: Redis publisher</p>"},{"location":"host-functions/redis/","title":"\ud83d\udee0\ufe0f Host functions","text":""},{"location":"host-functions/redis/#hostinitredisclient","title":"hostInitRedisClient","text":"<p><code>hostInitRedisClient</code>: initialize a Redis client it it does not exist.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"strings\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitRedisClient\nfunc hostInitRedisClient(offset uint64) uint64\nfunc InitRedisClient(redisClientId string, redisUri string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\njsonStrArguments := `{\"id\":\"` + redisClientId + `\",\"uri\":\"` + redisUri + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitRedisClient(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the redis client id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\nredisURI := GetEnv(\"REDIS_URI\")\nidRedisClient, errInit := InitRedisClient(\"redisDb\", redisURI)\nif errInit!= nil {\nPrint(\"\ud83d\ude21 \" + errInit.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + idRedisClient)\n}\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisClientArguments {\npub id: String,\npub uri: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum RedisError {\n#[error(\"Redis Client issue\")]\nClientFailure,\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostInitRedisClient(offset: u64) -&gt; u64;\n}\npub fn init_redis_client(redis_client_id: String, redis_uri: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\nlet args = RedisClientArguments {\nid: redis_client_id,\nuri: redis_uri,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostInitRedisClient(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::ClientFailure.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nlet redis_uri : String = get_env(\"REDIS_URI\".to_string());\nlet redis_client : Result&lt;String, Error&gt; = init_redis_client(\"redisDb\".to_string(), redis_uri);\nmatch redis_client {\nOk(value) =&gt; print(\"\ud83e\udd80 redis client: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/redis/#hostredisset","title":"hostRedisSet","text":"<p><code>hostRedisSet</code>: store a value with a key into the Redis database.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"strings\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitRedisClient\nfunc hostInitRedisClient(offset uint64) uint64\nfunc InitRedisClient(redisClientId string, redisUri string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\njsonStrArguments := `{\"id\":\"` + redisClientId + `\",\"uri\":\"` + redisUri + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitRedisClient(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the redis client id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hostRedisSet\nfunc hostRedisSet(offset uint64) uint64\nfunc RedisSet(redisClientId string, key string, value string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\",\n//    \"value\": \"Bob Morane\"\n// }\njsonStr := `{\"id\":\"` + redisClientId + `\",\"key\":\"` + key + `\",\"value\":\"` + value + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStr)\n// Call host function with the offset of the arguments\noffset := hostRedisSet(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostMemorySet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffResult := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffResult)\nJSONData, err := parser.ParseBytes(buffResult)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\nredisURI := GetEnv(\"REDIS_URI\")\nInitRedisClient(\"redisDb\", redisURI)\nk1, errSet1 := RedisSet(\"redisDb\", \"001\", \"Huey\")\nk2, errSet2 := RedisSet(\"redisDb\", \"002\", \"Dewey\")\nk3, errSet3 := RedisSet(\"redisDb\", \"003\", \"Louie\")\nallSetErrs := errors.Join(errSet1, errSet2, errSet3) if allSetErrs != nil {\nPrint(\"\ud83d\ude21 \" + allSetErrs.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + strings.Join([]string{k1,k2,k3}, \",\"))\n}\n/* output:\n        \ud83d\ude42 001,002,003\n    */\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisClientArguments {\npub id: String,\npub uri: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisArguments {\npub id: String,\npub key: String,\npub value: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum RedisError {\n#[error(\"Redis Client issue\")]\nClientFailure,\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostInitRedisClient(offset: u64) -&gt; u64;\n}\npub fn init_redis_client(redis_client_id: String, redis_uri: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\nlet args = RedisClientArguments {\nid: redis_client_id,\nuri: redis_uri,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostInitRedisClient(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::ClientFailure.into());\n}\n}\nextern \"C\" {\nfn hostRedisSet(offset: u64) -&gt; u64;\n}\npub fn redis_set(redis_client_id: String, key: String, value: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\",\n//    \"value\": \"Bob Morane\"\n// }\nlet args = RedisArguments {\nid: redis_client_id, key: key,\nvalue: value,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostRedisSet(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostRedisSet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::StoreFailure.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nlet redis_uri : String = get_env(\"REDIS_URI\".to_string());\nlet redis_client : Result&lt;String, Error&gt; = init_redis_client(\"redisDb\".to_string(), redis_uri);\nmatch redis_set(\"redisDb\".to_string(), \"100\".to_string(), \"Huey\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 saved value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch redis_set(\"redisDb\".to_string(), \"200\".to_string(), \"Dewey\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 saved value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch redis_set(\"redisDb\".to_string(), \"300\".to_string(), \"Louie\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 saved value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/redis/#hostredisget","title":"hostRedisGet","text":"<p><code>hostRedisGet</code>: retrieve a value with a key from the Redis database.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"strings\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitRedisClient\nfunc hostInitRedisClient(offset uint64) uint64\nfunc InitRedisClient(redisClientId string, redisUri string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\njsonStrArguments := `{\"id\":\"` + redisClientId + `\",\"uri\":\"` + redisUri + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitRedisClient(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the redis client id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hostRedisGet\nfunc hostRedisGet(offset uint64) uint64\nfunc RedisGet(redisClientId string, key string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\"\n// }\njsonStr := `{\"id\":\"` + redisClientId + `\",\"key\":\"` + key + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStr)\n// Call the host function\noffset := hostRedisGet(arguments.Offset())\n// Get result (the value associated to the key) from shared memory\n// The host function (hostRedisGet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryValue := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryValue.Length())\nmemoryValue.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\nredisURI := GetEnv(\"REDIS_URI\")\nInitRedisClient(\"redisDb\", redisURI)\nv1, errGet1 := RedisGet(\"redisDb\", \"001\")\nv2, errGet2 := RedisGet(\"redisDb\", \"002\")\nv3, errGet3 := RedisGet(\"redisDb\", \"003\")\nallGetErrs := errors.Join(errGet1, errGet2, errGet3) if allGetErrs != nil {\nPrint(\"\ud83d\ude21 \" + allSetErrs.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + strings.Join([]string{v1,v2,v3}, \",\"))\n}\n/* output:\n        \ud83d\ude42 Huey,Dewey,Louie\n    */\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisClientArguments {\npub id: String,\npub uri: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisArguments {\npub id: String,\npub key: String,\npub value: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum RedisError {\n#[error(\"Redis Client issue\")]\nClientFailure,\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostInitRedisClient(offset: u64) -&gt; u64;\n}\npub fn init_redis_client(redis_client_id: String, redis_uri: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\nlet args = RedisClientArguments {\nid: redis_client_id,\nuri: redis_uri,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostInitRedisClient(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::ClientFailure.into());\n}\n}\nextern \"C\" {\nfn hostRedisGet(offset: u64) -&gt; u64;\n}\npub fn redis_get(redis_client_id: String, key: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\",\n//    \"value\": \"\"\n// }\nlet args = RedisArguments {\nid: redis_client_id, key: key,\nvalue: String::new(),\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostRedisGet(memory_json_str.offset) };\n// Get result (the value associated to the key) from shared memory\n// The host function (hostRedisGet) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::NotFound.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nlet redis_uri : String = get_env(\"REDIS_URI\".to_string());\nlet redis_client : Result&lt;String, Error&gt; = init_redis_client(\"redisDb\".to_string(), redis_uri);\nmatch redis_get(\"redisDb\".to_string(), \"100\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch redis_get(\"redisDb\".to_string(), \"200\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch redis_get(\"redisDb\".to_string(), \"300\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nmatch redis_get(\"redisDb\".to_string(), \"400\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 value: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/redis/#hostredisdel","title":"hostRedisDel","text":"<p><code>hostRedisDel</code>: delete a value with a key from the Redis database.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"strings\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitRedisClient\nfunc hostInitRedisClient(offset uint64) uint64\nfunc InitRedisClient(redisClientId string, redisUri string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\njsonStrArguments := `{\"id\":\"` + redisClientId + `\",\"uri\":\"` + redisUri + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitRedisClient(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the redis client id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hostRedisDel\nfunc hostRedisDel(offset uint64) uint64\nfunc RedisDel(redisClientId string, key string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\"\n// }\njsonStr := `{\"id\":\"` + redisClientId + `\",\"key\":\"` + key + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStr)\n// Call the host function\noffset := hostRedisDel(arguments.Offset())\n// Get result (the value associated to the key) from shared memory\n// The host function (hostRedisDel) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryValue := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryValue.Length())\nmemoryValue.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\nredisURI := GetEnv(\"REDIS_URI\")\nInitRedisClient(\"redisDb\", redisURI)\nkey, errDel := RedisDel(\"redisDb\", \"002\")\nif errDel != nil {\nPrint(\"\ud83d\ude21 \" + errDel.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + key)\n}\n/* output:\n        \ud83d\ude42 002\n    */\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisClientArguments {\npub id: String,\npub uri: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisArguments {\npub id: String,\npub key: String,\npub value: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum RedisError {\n#[error(\"Redis Client issue\")]\nClientFailure,\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostInitRedisClient(offset: u64) -&gt; u64;\n}\npub fn init_redis_client(redis_client_id: String, redis_uri: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\nlet args = RedisClientArguments {\nid: redis_client_id,\nuri: redis_uri,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostInitRedisClient(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::ClientFailure.into());\n}\n}\nextern \"C\" {\nfn hostRedisDel(offset: u64) -&gt; u64;\n}\npub fn redis_del(redis_client_id: String, key: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\",\n//    \"value\": \"\"\n// }\nlet args = RedisArguments {\nid: redis_client_id, key: key,\nvalue: String::new(),\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostRedisDel(memory_json_str.offset) };\n// Get result (the value associated to the key) from shared memory\n// The host function (hostRedisDel) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::NotFound.into());\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nlet redis_uri : String = get_env(\"REDIS_URI\".to_string());\nlet redis_client : Result&lt;String, Error&gt; = init_redis_client(\"redisDb\".to_string(), redis_uri);\nmatch redis_del(\"redisDb\".to_string(), \"200\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 deleted key: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"host-functions/redis/#hostredisfilter","title":"hostRedisFilter","text":"<p><code>hostRedisFilter</code>: retrieve keys with a filter from the Redis database.</p> GoRust <pre><code>package main\nimport (\n\"errors\"\n\"strings\"\n\"github.com/extism/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\n//export hostPrint\nfunc hostPrint(offset uint64) uint64\nfunc Print(text string) {\nmemoryText := pdk.AllocateString(text)\nhostPrint(memoryText.Offset())\n}\n//export hostGetEnv\nfunc hostGetEnv(offset uint64) uint64\nfunc GetEnv(name string) string {\n// copy the name of the environment variable to the shared memory\nvariableName := pdk.AllocateString(name)\n// call the host function\noffset := hostGetEnv(variableName.Offset())\n// read the value of the result from the shared memory\nvariableValue := pdk.FindMemory(offset)\nbuffer := make([]byte, variableValue.Length())\nvariableValue.Load(buffer)\n// cast the buffer to string and return the value\nenvVarValue := string(buffer)\nreturn envVarValue\n}\nvar parser = fastjson.Parser{}\n//export hostInitRedisClient\nfunc hostInitRedisClient(offset uint64) uint64\nfunc InitRedisClient(redisClientId string, redisUri string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\njsonStrArguments := `{\"id\":\"` + redisClientId + `\",\"uri\":\"` + redisUri + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStrArguments)\n// Call the host function with Json string argument\noffset := hostInitRedisClient(arguments.Offset())\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the redis client id\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryResult := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryResult.Length())\nmemoryResult.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hostRedisFilter\nfunc hostRedisFilter(offset uint64) uint64\nfunc RedisFilter(redisClientId string, key string) (string, error) {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"filter ex 00*\"\n// }\njsonStr := `{\"id\":\"` + redisClientId + `\",\"key\":\"` + key + `\"}`\n// Copy the string value to the shared memory\narguments := pdk.AllocateString(jsonStr)\n// Call the host function\noffset := hostRedisFilter(arguments.Offset())\n// Get result (the value associated to the key) from shared memory\n// The host function (hostRedisDel) returns a JSON buffer:\n// {\n//   \"success\": \"array of keys\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nmemoryValue := pdk.FindMemory(offset)\nbuffer := make([]byte, memoryValue.Length())\nmemoryValue.Load(buffer)\nJSONData, err := parser.ParseBytes(buffer)\nif err != nil {\nreturn \"\", err\n}\nif len(JSONData.GetStringBytes(\"failure\")) == 0 {\nreturn string(JSONData.GetStringBytes(\"success\")), nil\n} else {\nreturn \"\", errors.New(string(JSONData.GetStringBytes(\"failure\")))\n}\n}\n//export hello\nfunc hello() uint64 {\nredisURI := GetEnv(\"REDIS_URI\")\nInitRedisClient(\"redisDb\", redisURI)\nkeys, errKeys := RedisFilter(\"redisDb\", \"00*\")\nif errKeys != nil {\nPrint(\"\ud83d\ude21 \" + errKeys.Error())\n} else {\nPrint(\"\ud83d\ude42 \" + keys)\n}\n/* output:\n        \ud83d\ude42 [\"003\",\"001\"]\n    */\nreturn 0\n}\nfunc main() {}\n</code></pre> <pre><code>use extism_pdk::*;\nuse serde::{Serialize, Deserialize};\nuse thiserror::Error;\nextern \"C\" {\nfn hostPrint(ptr: u64) -&gt; u64;\n}\npub fn print(text: String) {\nlet mut memory_text: Memory = extism_pdk::Memory::new(text.len());\nmemory_text.store(text);\nunsafe { hostPrint(memory_text.offset) };\n}\nextern \"C\" {\nfn hostGetEnv(ptr: u64) -&gt; u64;\n}\npub fn get_env(name: String) -&gt; String {\n// copy the name of the environment variable to the shared memory\nlet mut variable_name: Memory = extism_pdk::Memory::new(name.len());\nvariable_name.store(name);\n// call the host function\nlet offset: u64 = unsafe { hostGetEnv(variable_name.offset) };\n// read the value of the result from the shared memory\nlet variable_value: Memory = extism_pdk::Memory::find(offset).unwrap();\n// return the value\nreturn variable_value.to_string().unwrap()\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisClientArguments {\npub id: String,\npub uri: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct RedisArguments {\npub id: String,\npub key: String,\npub value: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\nstruct StringResult {\npub success: String,\npub failure: String,\n}\n#[derive(Error, Debug)]\npub enum RedisError {\n#[error(\"Redis Client issue\")]\nClientFailure,\n#[error(\"Store issue\")]\nStoreFailure,\n#[error(\"Not found\")]\nNotFound,\n}\nextern \"C\" {\nfn hostInitRedisClient(offset: u64) -&gt; u64;\n}\npub fn init_redis_client(redis_client_id: String, redis_uri: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"uri\": \"redis uri\"\n// }\nlet args = RedisClientArguments {\nid: redis_client_id,\nuri: redis_uri,\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostInitRedisClient(memory_json_str.offset) };\n// Get result from the shared memory\n// The host function (hostInitRedisClient) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::ClientFailure.into());\n}\n}\nextern \"C\" {\nfn hostRedisFilter(offset: u64) -&gt; u64;\n}\npub fn redis_filter(redis_client_id: String, key: String) -&gt; Result&lt;String, Error&gt; {\n// Prepare the arguments for the host function\n// with a JSON string:\n// {\n//    \"id\": \"id of the redis client\",\n//    \"key\": \"name\",\n//    \"value\": \"\"\n// }\nlet args = RedisArguments {\nid: redis_client_id, key: key,\nvalue: String::new(),\n};\nlet json_str: String = serde_json::to_string(&amp;args).unwrap();\n// Copy the string value to the shared memory\nlet mut memory_json_str: Memory = extism_pdk::Memory::new(json_str.len());\nmemory_json_str.store(json_str);\n// Call host function with the offset of the arguments\nlet offset: u64 = unsafe { hostRedisFilter(memory_json_str.offset) };\n// Get result (the value associated to the key) from shared memory\n// The host function (hostRedisDel) returns a JSON buffer:\n// {\n//   \"success\": \"the value associated to the key\",\n//   \"failure\": \"error message if error, else empty\"\n// }\nlet memory_result: Memory = extism_pdk::Memory::find(offset).unwrap();\nlet json_string:String = memory_result.to_string().unwrap();\nlet result: StringResult = serde_json::from_str(&amp;json_string).unwrap();\nif result.failure.is_empty()  {\nreturn Ok(result.success);\n} else {\nreturn Err(RedisError::NotFound.into()); //???\n}\n}\n#[plugin_fn]\npub fn hello(_: String) -&gt; FnResult&lt;u64&gt; {\nlet redis_uri : String = get_env(\"REDIS_URI\".to_string());\nlet redis_client : Result&lt;String, Error&gt; = init_redis_client(\"redisDb\".to_string(), redis_uri);\nmatch redis_filter(\"redisDb\".to_string(), \"*00\".to_string()) {\nOk(value)  =&gt; print(\"\ud83e\udd80 keys: \".to_string() + &amp;value),\nErr(error) =&gt; print(\"\ud83d\ude21 error: \".to_string() + &amp;error.to_string()),\n}\nOk(0)\n}\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/","title":"Slingshot PDK","text":"<p>Plug-in development kit</p>"},{"location":"slingshot-pdk/go-pdk/#slingshot-go-pdk","title":"Slingshot Go PDK","text":""},{"location":"slingshot-pdk/go-pdk/#structure-of-a-plugin","title":"Structure of a plugin","text":"<pre><code>package main\nimport (\nslingshot \"github.com/bots-garden/slingshot/go-pdk\"\n)\nfunc helloHandler(argHandler []byte) []byte {\ninput := string(argHandler)\nslingshot.Print(\"\ud83d\udc4b hello world \ud83c\udf0d \" + string(input))\nreturn []byte(\"\ud83d\udc4b Hello World \ud83c\udf0d\")\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(helloHandler)\n}\nfunc main() {}\n</code></pre> <ol> <li>You must export a function (it will be called at the execution, here, it's <code>callHandler</code>).</li> <li><code>slingshot.ExecHandler</code> is an helper to execute the function (<code>helloHandler</code>). This helper will read the wasm shared memory to get the argument of the function (<code>argHandler []byte</code>).</li> <li>Then the helper executes the function.</li> <li>And finally write to the wasm shared memory to return the result of the function (<code>[]byte(\"\ud83d\udc4b Hello World \ud83c\udf0d\")</code>).</li> </ol>"},{"location":"slingshot-pdk/go-pdk/#build-the-slingshot-plugin","title":"Build the Slingshot plugin","text":"<pre><code>tinygo build -scheduler=none --no-debug \\\n-o print.wasm \\\n-target wasi main.go\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#run-the-slingshot-plugin","title":"Run the Slingshot plugin","text":"<pre><code>./slingshot run --wasm=./print.wasm \\\n--handler=callHandler \\\n--input=\"\ud83e\udd13 I'm a geek\"\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#slingshot-host-functions","title":"Slingshot host functions","text":"<p>\ud83d\udea7 This is a work in progress</p> <ul> <li><code>slingshot.Print(text string)</code></li> <li><code>slingshot.Log(text string)</code></li> <li><code>slingshot.MemorySet(key string, value string) (string, error)</code></li> <li><code>slingshot.MemoryGet(key string) (string, error)</code></li> <li><code>slingshot.InitRedisClient(redisClientId string, redisUri string) (string, error)</code></li> <li><code>slingshot.RedisSet(redisClientId string, key string, value string) (string, error)</code></li> <li><code>slingshot.RedisGet(redisClientId string, key string) (string, error)</code></li> <li><code>slingshot.RedisDel(redisClientId string, key string) (string, error)</code></li> <li><code>slingshot.RedisFilter(redisClientId string, key string) (string, error)</code></li> <li><code>slingshot.RedisPublish(redisClientId string, channel string, payload string) (string, error)</code></li> <li><code>slingshot.InitNatsConnection(natsConnectionId string, natsUrl string) (string, error)</code></li> <li><code>slingshot.NatsPublish(natsConnectionId string, subject string, data string) (string, error)</code></li> <li><code>slingshot.ReadFile(filePath string) (string, error)</code></li> <li><code>slingshot.WriteFile(filePath string, text string) error</code></li> </ul>"},{"location":"slingshot-pdk/go-pdk/#other-examples","title":"Other examples","text":""},{"location":"slingshot-pdk/go-pdk/#http-nano-service-plug-in","title":"HTTP nano-service plug-in","text":"<pre><code>package main\nimport (\n\"strings\"\nslingshot \"github.com/bots-garden/slingshot/go-pdk\"\n\"github.com/valyala/fastjson\"\n)\nvar parser = fastjson.Parser{}\nfunc helloHandler(http_request_data []byte) []byte {\nvar text string\nvar code string\nJSONData, err := parser.ParseBytes(http_request_data)\nif err != nil {\ntext = \"\ud83d\ude21 Error: \" + err.Error()\ncode = \"500\"\n} else {\ntext = \"\ud83e\ude75 Hello \" + string(JSONData.GetStringBytes(\"body\"))\ncode = \"200\"\n}\nheaders := []string{\n`\"Content-Type\": \"application/json; charset=utf-8\"`,\n`\"X-Slingshot-version\": \"0.0.0\"`,\n}\nheadersStr := strings.Join(headers, \",\")\nresponse := `{\"headers\":{` + headersStr + `}, \"textBody\": \"` + text + `\", \"statusCode\": ` + code + `}`\nreturn []byte(response)\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(helloHandler)\n}\nfunc main() {}\n</code></pre> <p>Run:</p> <pre><code>./slingshot listen --wasm=./hello.wasm \\\n--handler=callHandler \\\n--http-port=7070\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#redis-subscriber-plug-in","title":"Redis subscriber plug-in","text":"<pre><code>package main\nimport (\nslingshot \"github.com/bots-garden/slingshot/go-pdk\"\n)\nfunc messageHandler(input []byte) []byte {\nslingshot.Print(\"\ud83d\udc4b message: \" + string(input))\nreturn nil\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(messageHandler)\n}\nfunc main() {}\n</code></pre> <p>Run:</p> <pre><code>./slingshot redis subscribe \\\n--wasm=./redissub.wasm \\\n--handler=callHandler \\\n--uri=${REDIS_URI} \\\n--client-id=pubsubcli \\\n--channel=news\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#redis-publisher-plug-in","title":"Redis publisher plug-in","text":"<pre><code>package main\nimport slingshot \"github.com/bots-garden/slingshot/go-pdk\"\nfunc publishHandler(input []byte) []byte {\nredisURI := slingshot.GetEnv(\"REDIS_URI\")\nidRedisClient, errInit := slingshot.InitRedisClient(\"pubsubcli\", redisURI)\nif errInit != nil {\nslingshot.Print(\"\ud83d\ude21 \" + errInit.Error())\n} else {\nslingshot.Print(\"\ud83d\ude42 \" + idRedisClient)\n}\nslingshot.RedisPublish(\"pubsubcli\", \"news\", string(input))\nreturn nil\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(publishHandler)\n}\nfunc main() {}\n</code></pre> <p>Run:</p> <pre><code>./slingshot run --wasm=./redispub.wasm \\\n--handler=callHandler \\\n--input=\"I \ud83d\udc9c Wasm \u2728\"\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#nats-subscriber-plug-in","title":"Nats subscriber plug-in","text":"<pre><code>package main\nimport slingshot \"github.com/bots-garden/slingshot/go-pdk\"\nfunc messageHandler(input []byte) []byte {\nslingshot.Print(\"\ud83d\udc4b NATS message: \" + string(input))\nreturn nil\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(messageHandler)\n}\nfunc main() {}\n</code></pre> <p>Run:</p> <pre><code>./slingshot nats subscribe \\\n--wasm=./natssub.wasm \\\n--handler=callHandler \\\n--url=nats://0.0.0.0:4222 \\\n--connection-id=natsconn01 \\\n--subject=news\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#nats-publisher-plug-in","title":"Nats publisher plug-in","text":"<pre><code>package main\nimport (\nslingshot \"github.com/bots-garden/slingshot/go-pdk\"\n)\nfunc publishHandler(input []byte) []byte {\nnatsURL := slingshot.GetEnv(\"NATS_URL\")\nslingshot.Print(\"\ud83d\udc9c NATS_URL: \" + natsURL)\nidNatsConnection, errInit := slingshot.InitNatsConnection(\"natsconn01\", natsURL)\nif errInit != nil {\nslingshot.Print(\"\ud83d\ude21 \" + errInit.Error())\n} else {\nslingshot.Print(\"\ud83d\ude42 \" + idNatsConnection)\n}\nres, err := slingshot.NatsPublish(\"natsconn01\", \"news\", string(input))\nif err != nil {\nslingshot.Print(\"\ud83d\ude21 \" + err.Error())\n} else {\nslingshot.Print(\"\ud83d\ude42 \" + res)\n}\nreturn nil\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(publishHandler)\n}\nfunc main() {}\n</code></pre> <p>Run:</p> <pre><code>./slingshot run --wasm=./natspub.wasm \\\n--handler=callHandler \\\n--input=\"I \ud83d\udc9c Wasm \u2728\"\n</code></pre>"},{"location":"slingshot-pdk/go-pdk/#read-write-a-file","title":"Read / Write a file","text":"<pre><code>package main\nimport (\nslingshot \"github.com/bots-garden/slingshot/go-pdk\"\n)\nfunc helloHandler(argHandler []byte) []byte {\ncontent, err := slingshot.ReadFile(\"./hello.txt\")\nif err != nil {\nslingshot.Log(\"\ud83d\ude21 \" + err.Error())\n}\nslingshot.Print(content)\ntext := `\n    &lt;html&gt;\n      &lt;h1&gt;\"Hello World!!!\"&lt;/h1&gt;\n    &lt;/html&gt;\n    `\nerrWrite := slingshot.WriteFile(\"./index.html\", text)\nif errWrite != nil {\nslingshot.Log(\"\ud83d\ude21 \" + errWrite.Error())\n}\nreturn []byte(\"\ud83d\udc4b Hello World \ud83c\udf0d\")\n}\n//export callHandler\nfunc callHandler() {\nslingshot.ExecHandler(helloHandler)\n}\nfunc main() {}\n</code></pre> <p>Run:</p> <pre><code>./slingshot run --wasm=./files.wasm \\\n--handler=callHandler\n</code></pre>"},{"location":"slingshot-pdk/intro/","title":"Slingshot PDK","text":"<p>Plug-in development kit</p> <p>The Slingshot PDK is a layer under the Extism PDK to ease the writting of a wasm plugin and simplify the call of the host functions.</p>"},{"location":"slingshot-pdk/rust-pdk/","title":"Slingshot PDK","text":"<p>Plug-in development kit</p>"},{"location":"slingshot-pdk/rust-pdk/#slingshot-rust-pdk","title":"Slingshot Rust PDK","text":"<p>\ud83d\udea7 This is a work in progress</p>"}]}